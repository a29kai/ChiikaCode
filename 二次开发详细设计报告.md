# ChiikaCode 二次开发详细设计报告

ChiikaCode是一个利用RAG（Retrieval-Augmented Generation）进行工程级代码生成的VS Code插件，旨在通过集成后端API来实现项目的自动化生成、文件上传与处理、以及自动化提问等功能。以下是项目的设计和实现概述：

## 一、前端工程级别代码生成功能部分

### 1.1. 插件设计与架构

VS Code 插件的核心目标是为用户提供一个直观的界面，支持生成项目代码、上传文件与文件夹、以及通过提问与后端交互。设计上采用了VS Code的Webview API，后端通过HTTP请求响应插件前端。

#### 主要组件

- **Webview**：前端UI由Webview承载。UI包括语言选择、项目需求输入框、函数名与参数输入框、以及多个交互按钮（生成项目、生成代码、提问、上传文件等）。
- **后端交互**：插件与本地后端服务通过HTTP请求进行数据交互，执行代码生成、项目生成等操作。后端服务通常提供RESTful接口，如生成项目、生成代码、回答问题、文件上传等。
- **文件系统操作**：通过VS Code API操作工作区文件系统，创建目录、写入文件，甚至上传文件和文件夹。

#### 工作流程

1. 用户在插件UI中选择编程语言、输入项目需求或代码生成相关信息。
2. 前端通过`postMessage`向后端发送请求，后端根据请求生成项目或代码并返回结果。
3. 如果涉及文件上传，前端会获取文件路径或文件夹路径，通过HTTP上传到后端进行处理。
4. 后端处理完成后，前端显示相应的结果或代码，用户可以在VS Code中查看、编辑和保存。

### 1.2. 插件设计与架构

#### 1.2.1. 观察者模式

在此项目中，`onDidReceiveMessage` 和 `window.addEventListener('message')` 便是典型的观察者模式应用。前端UI通过事件监听机制接收后端返回的消息，并在接收到消息后更新UI。具体表现为：

- `webviewView.webview.onDidReceiveMessage` 用于监听用户与Webview交互的消息。
- `window.addEventListener('message')` 监听后端消息并更新UI，例如生成的代码、上传结果等。

这种模式使得前端与后端解耦，消息的发送者（后端或前端）与接收者（前端UI）不需要直接引用彼此。

#### 1.2.2. 工厂模式

在文件创建和保存的部分，使用了工厂模式来生成文件。具体的实现体现在`saveGeneratedFiles`和`processNode`方法：

- `processNode`方法根据传入的`nodeType`来决定是创建文件还是文件夹。文件夹会调用`createDirectory`方法，文件则通过`WorkspaceEdit`来创建文件并写入内容。这是工厂模式的一种实现，动态生成不同类型的文件或文件夹。

#### 1.2.3. 策略模式

在处理不同类型的请求时，策略模式应用在`handleMessage`方法中。不同的命令（如`generateProject`、`askQuestion`、`uploadFile`等）有不同的处理策略。根据消息中的`command`字段，选择相应的处理方法来执行：

- 生成项目：调用`generateProject`接口。
- 提问：调用`askQuestion`接口。
- 上传文件：调用`uploadFile`接口。
- 生成代码：调用`generateCode`接口。
  

这种方式可以将不同的处理逻辑封装到独立的策略中，便于扩展和维护。

#### 1.2.4. 单例模式

在插件中，`NewViewProvider` 类采用了单例模式的设计。`viewType` 是该类的静态常量，它在VS Code中只会被实例化一次。这个模式确保了只有一个实例处理所有的Webview交互。

### 1.3. 实例分析

#### 1.3.1. 观察者模式实例

```js
webviewView.webview.onDidReceiveMessage(async message => {
    await this.handleMessage(message, webviewView);
});
```

![前端观察者模式](前端观察者模式.png)

在这里，`onDidReceiveMessage`监听从前端发来的消息，当接收到消息后执行`handleMessage`方法，更新UI或者执行相应的后台逻辑。每次用户在Webview中交互时，都会触发这个监听器。

#### 1.3.2. 工厂模式实例

```js
if (nodeType === 'folder') {
    const absoluteFolderPath = vscode.Uri.file(`${workspacePath}/${currentPath}`);
    await vscode.workspace.fs.createDirectory(absoluteFolderPath);
    if (node.children && Array.isArray(node.children)) {
        for (const childNode of node.children) {
            await this.processNode(childNode, workspacePath, currentPath);
        }
    }
} else if (nodeType === 'code' || nodeType === 'file') {
    const content = node.content || '';
    const absoluteFilePath = vscode.Uri.file(`${workspacePath}/${currentPath}`);
    const fileFolder = absoluteFilePath.with({ path: absoluteFilePath.path.split('/').slice(0, -1).join('/') });

    await vscode.workspace.fs.createDirectory(vscode.Uri.file(fileFolder.path));
    const edit = new vscode.WorkspaceEdit();
    edit.createFile(absoluteFilePath, { overwrite: true });
    edit.set(absoluteFilePath, [
        new vscode.TextEdit(new vscode.Range(0, 0, 0, 0), content)
    ]);
    await vscode.workspace.applyEdit(edit);
}
```

这段代码是文件生成和目录创建的核心逻辑。根据nodeType判断是文件还是文件夹，并通过不同的方式来处理它们。这是典型的工厂模式，每种类型的数据（文件或文件夹）都有不同的处理策略。

![前端工厂模式](前端工厂模式.png)

#### 1.3.3. 策略模式实例

```js
switch (message.command) {
    case 'generateProject':
        // 生成项目的策略
        break;
    case 'askQuestion':
        // 提问的策略
        break;
    case 'uploadFile':
        // 上传文件的策略
        break;
    default:
        // 其他默认策略
        break;
}
```

根据不同的`command`值，选择不同的策略来处理。每种策略都封装了特定的业务逻辑，使得系统可以灵活地扩展。

![前端策略模式](前端策略模式.png)

#### 1.3.4. 单例模式

在插件中，`NewViewProvider` 类采用了单例模式的设计。`viewType` 是该类的静态常量，它在VS Code中只会被实例化一次。这个模式确保了只有一个实例处理所有的Webview交互。

### 1.4. 前端分析结语

ChiikaCode插件的设计考虑了用户体验与后端处理的分离，采用了多种设计模式来确保系统的高扩展性和低耦合度。通过合理地应用观察者模式、工厂模式、策略模式和单例模式，该插件能够有效地处理不同类型的用户交互，并与后端系统实现无缝的集成。



## 二、后端功能模块部分

在后端，我们通过HTTP请求提供了若干接口，来实现和前端插件的数据交互。主要模块包括：

- 项目级代码生成
- 基于文档检索的代码补全
- 可运行的函数级代码生成
- 基于 streamlit 的交互原型设计

### 2.1 项目级代码生成

### 2.2 基于文档检索的代码补全

### 2.3 可运行的函数级代码生成

#### 2.3.1 功能简述

该模块提供了一个接口函数 `getExecutable`，参数为：

- `functionName`：函数名
- `arguements`：函数参数列表
- `docString`：函数文档字符串

返回值是：

- `code`：生成的函数字符串，并且保证生成的函数可以正常运行

用户可以通过输入期望生成的函数名、函数说明注释以及函数参数列表，来自动补全函数的功能实现。

#### 2.3.2 设计模式

##### 2.3.2.1 代理模式

代理模式实例：（服务端已经打包成可执行文件，因此这里只展示客户端代码）

<img src="./backend assets/7_proxy.png" style="zoom:67%;" />

类图：

<img src="./backend assets/6_proxy.png" style="zoom:75%;" />

ollama 将代码补全接口封装成代理模式以供不同程序进行调用。当用户需要使用代码补全功能获得补全的代码时，只要向服务端发送请求，并等待服务端响应即可。

这样可以实现延迟初始化（虚拟代理）。如果使用本地运行代码补全模型，模型的初始化需要消耗较多系统资源， 一直保持该对象运行会消耗系统资源时， 此时使用代理模式自动进行系统资源管理。

**优点：**

- 你可以在客户端毫无察觉的情况下控制服务对象。
- 如果客户端对服务对象的生命周期没有特殊要求， 你以对生命周期进行管理。
- 即使服务对象还未准备好或不存在， 代理也可以正常工作。
- 开闭原则，可以在不对服务或客户端做出修改的情况下创建新代理。
- 由于采用统一的网络协议，可以提供更好的跨编程语言适配。

**缺点：**

-  服务响应可能会延迟。

### 2.4 基于 streamlit 的交互原型设计

#### 2.4.1功能简述

由于前端和后端非同步开发，因此在开发后端过程中，使用 streamlit 库进行原型设计，用于测试代码功能，方便调式代码和发现 bug。

#### 2.4.2 设计模式

##### 2.4.2.1 观察者模式

观察者模式实例：

<img src="./backend assets/1_observer.png" style="zoom:50%;" /><img src="./backend assets/2_observer.png" style="zoom:50%;" />

类图：

<img src="./backend assets/3_observer.png" style="zoom:75%;" />

在 **streamlit** 库的框架下，所有的持久的变量都需要通过 **session state** 储存。基于这个框架，在观察者模式中，设计了两个接口：`Oberver` 和 `Subject`。并实现了具体的 `SessionStateObserver` 和 `SesstionStateSubject` 类。

1. 将业务逻辑拆成两部分： 代码的核心功作为主题，管理 **session state** 的内容；前端显示的代码则将转化为一组观察者类，订阅 **session state**，通过 **session state** 的变化来更新界面。
2. 声明观察者接口。 该接口声明一个 `update` 方法。
3. 主题定义了一些接口来在列表中添加和删除观察者。
4. 创建具体主题类。 每次主题发生了重要事件时都必须通知所有的观察者。
5. 客户端必须生成所需的全部观察者， 并在相应的主题中完成注册工作

**优点：**

- 观察者列表是动态的， 因此观察者可随时加入或离开该列表。
- 开闭原则，无需修改主题代码就能引入新的观察者类。
- 可以在运行时建立对象之间的联系。

**缺点：**

- 观察者的通知顺序是随机的。
- 设计模式会增加代码的复杂性。

##### 2.4.2.2 备忘录模式

备忘录模式实例：

<img src="./backend assets/4_memento.png" style="zoom:67%;" />

类图：

<img src="./backend assets/5_memento.png"/>

当用户在网页上进行文字编辑、功能切换等操作时，允许用户进行撤销操作，以退回之前的编辑状态。撤销功能通过备忘录模式实现。

1. 备忘录模式将创建状态快照 （Snapshot） 的工作委派给实际状态的拥有者 `Originator` 对象。 这样其他对象就不再需要从 “外部” 复制网页的 **session state** 状态。
2. 将对象状态的副本存储在 `Memento` 对象中。 除了创建备忘录的对象外， 任何对象都不能访问备忘录的内容，即 **session state** 的内容。 其他对象必须使用受限接口与备忘录进行交互， 它们可以获取快照的元数据 （创建时间和操作名称等）， 但不能获取快照中原始对象的状态。
3. 将备忘录保存在 `Caretaker` 对象中。 由于 `Caretaker` 仅通过受限接口与备忘录互动， 故其无法修改存储在备忘录内部的状态。 同时， `Originator` 拥有对备忘录所有成员的访问权限， 从而能随时恢复其以前的状态。
4. 当用户触发撤销操作时， 历史类将从栈中取回最近的备忘录， 并将其传递给编辑器以请求进行回滚。

**优点：**

- 可以在不破坏对象封装情况的前提下创建对象状态快照。
- 可以通过让 `Caretaker` 维护 `Originator` 状态历史记录来简化代码。

**缺点：**

- 如果客户端过于频繁地创建备忘录， 程序将消耗大量内存。
- `Caretaker` 必须完整跟踪 `Originator` 的生命周期， 这样才能销毁弃用的备忘录。
- 绝大部分动态编程语言 （例如 PHP、 Python 和 JavaScript） 不能确保备忘录中的状态不被修改。
